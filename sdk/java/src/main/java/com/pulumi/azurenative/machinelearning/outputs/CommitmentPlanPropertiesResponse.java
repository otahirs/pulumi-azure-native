// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.machinelearning.outputs;

import com.pulumi.azurenative.machinelearning.outputs.PlanQuantityResponse;
import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class CommitmentPlanPropertiesResponse {
    /**
     * @return Indicates whether usage beyond the commitment plan&#39;s included quantities will be charged.
     * 
     */
    private Boolean chargeForOverage;
    /**
     * @return Indicates whether the commitment plan will incur a charge.
     * 
     */
    private Boolean chargeForPlan;
    /**
     * @return The date at which this commitment plan was created, in ISO 8601 format.
     * 
     */
    private String creationDate;
    /**
     * @return The included resource quantities this plan gives you.
     * 
     */
    private Map<String,PlanQuantityResponse> includedQuantities;
    /**
     * @return The maximum number of commitment associations that can be children of this commitment plan.
     * 
     */
    private Integer maxAssociationLimit;
    /**
     * @return The maximum scale-out capacity for this commitment plan.
     * 
     */
    private Integer maxCapacityLimit;
    /**
     * @return The minimum scale-out capacity for this commitment plan.
     * 
     */
    private Integer minCapacityLimit;
    /**
     * @return The Azure meter which will be used to charge for this commitment plan.
     * 
     */
    private String planMeter;
    /**
     * @return The frequency at which this commitment plan&#39;s included quantities are refilled.
     * 
     */
    private Integer refillFrequencyInDays;
    /**
     * @return Indicates whether this commitment plan will be moved into a suspended state if usage goes beyond the commitment plan&#39;s included quantities.
     * 
     */
    private Boolean suspendPlanOnOverage;

    private CommitmentPlanPropertiesResponse() {}
    /**
     * @return Indicates whether usage beyond the commitment plan&#39;s included quantities will be charged.
     * 
     */
    public Boolean chargeForOverage() {
        return this.chargeForOverage;
    }
    /**
     * @return Indicates whether the commitment plan will incur a charge.
     * 
     */
    public Boolean chargeForPlan() {
        return this.chargeForPlan;
    }
    /**
     * @return The date at which this commitment plan was created, in ISO 8601 format.
     * 
     */
    public String creationDate() {
        return this.creationDate;
    }
    /**
     * @return The included resource quantities this plan gives you.
     * 
     */
    public Map<String,PlanQuantityResponse> includedQuantities() {
        return this.includedQuantities;
    }
    /**
     * @return The maximum number of commitment associations that can be children of this commitment plan.
     * 
     */
    public Integer maxAssociationLimit() {
        return this.maxAssociationLimit;
    }
    /**
     * @return The maximum scale-out capacity for this commitment plan.
     * 
     */
    public Integer maxCapacityLimit() {
        return this.maxCapacityLimit;
    }
    /**
     * @return The minimum scale-out capacity for this commitment plan.
     * 
     */
    public Integer minCapacityLimit() {
        return this.minCapacityLimit;
    }
    /**
     * @return The Azure meter which will be used to charge for this commitment plan.
     * 
     */
    public String planMeter() {
        return this.planMeter;
    }
    /**
     * @return The frequency at which this commitment plan&#39;s included quantities are refilled.
     * 
     */
    public Integer refillFrequencyInDays() {
        return this.refillFrequencyInDays;
    }
    /**
     * @return Indicates whether this commitment plan will be moved into a suspended state if usage goes beyond the commitment plan&#39;s included quantities.
     * 
     */
    public Boolean suspendPlanOnOverage() {
        return this.suspendPlanOnOverage;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(CommitmentPlanPropertiesResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean chargeForOverage;
        private Boolean chargeForPlan;
        private String creationDate;
        private Map<String,PlanQuantityResponse> includedQuantities;
        private Integer maxAssociationLimit;
        private Integer maxCapacityLimit;
        private Integer minCapacityLimit;
        private String planMeter;
        private Integer refillFrequencyInDays;
        private Boolean suspendPlanOnOverage;
        public Builder() {}
        public Builder(CommitmentPlanPropertiesResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.chargeForOverage = defaults.chargeForOverage;
    	      this.chargeForPlan = defaults.chargeForPlan;
    	      this.creationDate = defaults.creationDate;
    	      this.includedQuantities = defaults.includedQuantities;
    	      this.maxAssociationLimit = defaults.maxAssociationLimit;
    	      this.maxCapacityLimit = defaults.maxCapacityLimit;
    	      this.minCapacityLimit = defaults.minCapacityLimit;
    	      this.planMeter = defaults.planMeter;
    	      this.refillFrequencyInDays = defaults.refillFrequencyInDays;
    	      this.suspendPlanOnOverage = defaults.suspendPlanOnOverage;
        }

        @CustomType.Setter
        public Builder chargeForOverage(Boolean chargeForOverage) {
            this.chargeForOverage = Objects.requireNonNull(chargeForOverage);
            return this;
        }
        @CustomType.Setter
        public Builder chargeForPlan(Boolean chargeForPlan) {
            this.chargeForPlan = Objects.requireNonNull(chargeForPlan);
            return this;
        }
        @CustomType.Setter
        public Builder creationDate(String creationDate) {
            this.creationDate = Objects.requireNonNull(creationDate);
            return this;
        }
        @CustomType.Setter
        public Builder includedQuantities(Map<String,PlanQuantityResponse> includedQuantities) {
            this.includedQuantities = Objects.requireNonNull(includedQuantities);
            return this;
        }
        @CustomType.Setter
        public Builder maxAssociationLimit(Integer maxAssociationLimit) {
            this.maxAssociationLimit = Objects.requireNonNull(maxAssociationLimit);
            return this;
        }
        @CustomType.Setter
        public Builder maxCapacityLimit(Integer maxCapacityLimit) {
            this.maxCapacityLimit = Objects.requireNonNull(maxCapacityLimit);
            return this;
        }
        @CustomType.Setter
        public Builder minCapacityLimit(Integer minCapacityLimit) {
            this.minCapacityLimit = Objects.requireNonNull(minCapacityLimit);
            return this;
        }
        @CustomType.Setter
        public Builder planMeter(String planMeter) {
            this.planMeter = Objects.requireNonNull(planMeter);
            return this;
        }
        @CustomType.Setter
        public Builder refillFrequencyInDays(Integer refillFrequencyInDays) {
            this.refillFrequencyInDays = Objects.requireNonNull(refillFrequencyInDays);
            return this;
        }
        @CustomType.Setter
        public Builder suspendPlanOnOverage(Boolean suspendPlanOnOverage) {
            this.suspendPlanOnOverage = Objects.requireNonNull(suspendPlanOnOverage);
            return this;
        }
        public CommitmentPlanPropertiesResponse build() {
            final var o = new CommitmentPlanPropertiesResponse();
            o.chargeForOverage = chargeForOverage;
            o.chargeForPlan = chargeForPlan;
            o.creationDate = creationDate;
            o.includedQuantities = includedQuantities;
            o.maxAssociationLimit = maxAssociationLimit;
            o.maxCapacityLimit = maxCapacityLimit;
            o.minCapacityLimit = minCapacityLimit;
            o.planMeter = planMeter;
            o.refillFrequencyInDays = refillFrequencyInDays;
            o.suspendPlanOnOverage = suspendPlanOnOverage;
            return o;
        }
    }
}
