// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ServiceFabric.V20210901PrivatePreview
{
    /// <summary>
    /// The network traffic is allowed or denied.
    /// </summary>
    [EnumType]
    public readonly struct Access : IEquatable<Access>
    {
        private readonly string _value;

        private Access(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Access Allow { get; } = new Access("allow");
        public static Access Deny { get; } = new Access("deny");

        public static bool operator ==(Access left, Access right) => left.Equals(right);
        public static bool operator !=(Access left, Access right) => !left.Equals(right);

        public static explicit operator string(Access value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Access other && Equals(other);
        public bool Equals(Access other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network security rule direction.
    /// </summary>
    [EnumType]
    public readonly struct Direction : IEquatable<Direction>
    {
        private readonly string _value;

        private Direction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Direction Inbound { get; } = new Direction("inbound");
        public static Direction Outbound { get; } = new Direction("outbound");

        public static bool operator ==(Direction left, Direction right) => left.Equals(right);
        public static bool operator !=(Direction left, Direction right) => !left.Equals(right);

        public static explicit operator string(Direction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Direction other && Equals(other);
        public bool Equals(Direction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Managed data disk type.
    /// </summary>
    [EnumType]
    public readonly struct DiskType : IEquatable<DiskType>
    {
        private readonly string _value;

        private DiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access.
        /// </summary>
        public static DiskType Standard_LRS { get; } = new DiskType("Standard_LRS");
        /// <summary>
        /// Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test.
        /// </summary>
        public static DiskType StandardSSD_LRS { get; } = new DiskType("StandardSSD_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage. Best for production and performance sensitive workloads.
        /// </summary>
        public static DiskType Premium_LRS { get; } = new DiskType("Premium_LRS");

        public static bool operator ==(DiskType left, DiskType right) => left.Equals(right);
        public static bool operator !=(DiskType left, DiskType right) => !left.Equals(right);

        public static explicit operator string(DiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskType other && Equals(other);
        public bool Equals(DiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP address type of this frontend configuration. If omitted the default value is IPv4.
    /// </summary>
    [EnumType]
    public readonly struct IPAddressType : IEquatable<IPAddressType>
    {
        private readonly string _value;

        private IPAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IPv4 address type.
        /// </summary>
        public static IPAddressType IPv4 { get; } = new IPAddressType("IPv4");
        /// <summary>
        /// IPv6 address type.
        /// </summary>
        public static IPAddressType IPv6 { get; } = new IPAddressType("IPv6");

        public static bool operator ==(IPAddressType left, IPAddressType right) => left.Equals(right);
        public static bool operator !=(IPAddressType left, IPAddressType right) => !left.Equals(right);

        public static explicit operator string(IPAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAddressType other && Equals(other);
        public bool Equals(IPAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network protocol this rule applies to.
    /// </summary>
    [EnumType]
    public readonly struct NsgProtocol : IEquatable<NsgProtocol>
    {
        private readonly string _value;

        private NsgProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NsgProtocol Http { get; } = new NsgProtocol("http");
        public static NsgProtocol Https { get; } = new NsgProtocol("https");
        public static NsgProtocol Tcp { get; } = new NsgProtocol("tcp");
        public static NsgProtocol Udp { get; } = new NsgProtocol("udp");
        public static NsgProtocol Icmp { get; } = new NsgProtocol("icmp");
        public static NsgProtocol Ah { get; } = new NsgProtocol("ah");
        public static NsgProtocol Esp { get; } = new NsgProtocol("esp");

        public static bool operator ==(NsgProtocol left, NsgProtocol right) => left.Equals(right);
        public static bool operator !=(NsgProtocol left, NsgProtocol right) => !left.Equals(right);

        public static explicit operator string(NsgProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NsgProtocol other && Equals(other);
        public bool Equals(NsgProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
