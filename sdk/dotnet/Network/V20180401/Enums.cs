// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Network.V20180401
{
    /// <summary>
    /// The DH Groups used in IKE Phase 1 for initial SA.
    /// </summary>
    [EnumType]
    public readonly struct DhGroup : IEquatable<DhGroup>
    {
        private readonly string _value;

        private DhGroup(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DhGroup None { get; } = new DhGroup("None");
        public static DhGroup DHGroup1 { get; } = new DhGroup("DHGroup1");
        public static DhGroup DHGroup2 { get; } = new DhGroup("DHGroup2");
        public static DhGroup DHGroup14 { get; } = new DhGroup("DHGroup14");
        public static DhGroup DHGroup2048 { get; } = new DhGroup("DHGroup2048");
        public static DhGroup ECP256 { get; } = new DhGroup("ECP256");
        public static DhGroup ECP384 { get; } = new DhGroup("ECP384");
        public static DhGroup DHGroup24 { get; } = new DhGroup("DHGroup24");

        public static bool operator ==(DhGroup left, DhGroup right) => left.Equals(right);
        public static bool operator !=(DhGroup left, DhGroup right) => !left.Equals(right);

        public static explicit operator string(DhGroup value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DhGroup other && Equals(other);
        public bool Equals(DhGroup other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IKE encryption algorithm (IKE phase 2).
    /// </summary>
    [EnumType]
    public readonly struct IkeEncryption : IEquatable<IkeEncryption>
    {
        private readonly string _value;

        private IkeEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IkeEncryption DES { get; } = new IkeEncryption("DES");
        public static IkeEncryption DES3 { get; } = new IkeEncryption("DES3");
        public static IkeEncryption AES128 { get; } = new IkeEncryption("AES128");
        public static IkeEncryption AES192 { get; } = new IkeEncryption("AES192");
        public static IkeEncryption AES256 { get; } = new IkeEncryption("AES256");
        public static IkeEncryption GCMAES256 { get; } = new IkeEncryption("GCMAES256");
        public static IkeEncryption GCMAES128 { get; } = new IkeEncryption("GCMAES128");

        public static bool operator ==(IkeEncryption left, IkeEncryption right) => left.Equals(right);
        public static bool operator !=(IkeEncryption left, IkeEncryption right) => !left.Equals(right);

        public static explicit operator string(IkeEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IkeEncryption other && Equals(other);
        public bool Equals(IkeEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IKE integrity algorithm (IKE phase 2).
    /// </summary>
    [EnumType]
    public readonly struct IkeIntegrity : IEquatable<IkeIntegrity>
    {
        private readonly string _value;

        private IkeIntegrity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IkeIntegrity MD5 { get; } = new IkeIntegrity("MD5");
        public static IkeIntegrity SHA1 { get; } = new IkeIntegrity("SHA1");
        public static IkeIntegrity SHA256 { get; } = new IkeIntegrity("SHA256");
        public static IkeIntegrity SHA384 { get; } = new IkeIntegrity("SHA384");
        public static IkeIntegrity GCMAES256 { get; } = new IkeIntegrity("GCMAES256");
        public static IkeIntegrity GCMAES128 { get; } = new IkeIntegrity("GCMAES128");

        public static bool operator ==(IkeIntegrity left, IkeIntegrity right) => left.Equals(right);
        public static bool operator !=(IkeIntegrity left, IkeIntegrity right) => !left.Equals(right);

        public static explicit operator string(IkeIntegrity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IkeIntegrity other && Equals(other);
        public bool Equals(IkeIntegrity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IPSec encryption algorithm (IKE phase 1).
    /// </summary>
    [EnumType]
    public readonly struct IpsecEncryption : IEquatable<IpsecEncryption>
    {
        private readonly string _value;

        private IpsecEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpsecEncryption None { get; } = new IpsecEncryption("None");
        public static IpsecEncryption DES { get; } = new IpsecEncryption("DES");
        public static IpsecEncryption DES3 { get; } = new IpsecEncryption("DES3");
        public static IpsecEncryption AES128 { get; } = new IpsecEncryption("AES128");
        public static IpsecEncryption AES192 { get; } = new IpsecEncryption("AES192");
        public static IpsecEncryption AES256 { get; } = new IpsecEncryption("AES256");
        public static IpsecEncryption GCMAES128 { get; } = new IpsecEncryption("GCMAES128");
        public static IpsecEncryption GCMAES192 { get; } = new IpsecEncryption("GCMAES192");
        public static IpsecEncryption GCMAES256 { get; } = new IpsecEncryption("GCMAES256");

        public static bool operator ==(IpsecEncryption left, IpsecEncryption right) => left.Equals(right);
        public static bool operator !=(IpsecEncryption left, IpsecEncryption right) => !left.Equals(right);

        public static explicit operator string(IpsecEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpsecEncryption other && Equals(other);
        public bool Equals(IpsecEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IPSec integrity algorithm (IKE phase 1).
    /// </summary>
    [EnumType]
    public readonly struct IpsecIntegrity : IEquatable<IpsecIntegrity>
    {
        private readonly string _value;

        private IpsecIntegrity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpsecIntegrity MD5 { get; } = new IpsecIntegrity("MD5");
        public static IpsecIntegrity SHA1 { get; } = new IpsecIntegrity("SHA1");
        public static IpsecIntegrity SHA256 { get; } = new IpsecIntegrity("SHA256");
        public static IpsecIntegrity GCMAES128 { get; } = new IpsecIntegrity("GCMAES128");
        public static IpsecIntegrity GCMAES192 { get; } = new IpsecIntegrity("GCMAES192");
        public static IpsecIntegrity GCMAES256 { get; } = new IpsecIntegrity("GCMAES256");

        public static bool operator ==(IpsecIntegrity left, IpsecIntegrity right) => left.Equals(right);
        public static bool operator !=(IpsecIntegrity left, IpsecIntegrity right) => !left.Equals(right);

        public static explicit operator string(IpsecIntegrity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpsecIntegrity other && Equals(other);
        public bool Equals(IpsecIntegrity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Pfs Groups used in IKE Phase 2 for new child SA.
    /// </summary>
    [EnumType]
    public readonly struct PfsGroup : IEquatable<PfsGroup>
    {
        private readonly string _value;

        private PfsGroup(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PfsGroup None { get; } = new PfsGroup("None");
        public static PfsGroup PFS1 { get; } = new PfsGroup("PFS1");
        public static PfsGroup PFS2 { get; } = new PfsGroup("PFS2");
        public static PfsGroup PFS2048 { get; } = new PfsGroup("PFS2048");
        public static PfsGroup ECP256 { get; } = new PfsGroup("ECP256");
        public static PfsGroup ECP384 { get; } = new PfsGroup("ECP384");
        public static PfsGroup PFS24 { get; } = new PfsGroup("PFS24");
        public static PfsGroup PFS14 { get; } = new PfsGroup("PFS14");
        public static PfsGroup PFSMM { get; } = new PfsGroup("PFSMM");

        public static bool operator ==(PfsGroup left, PfsGroup right) => left.Equals(right);
        public static bool operator !=(PfsGroup left, PfsGroup right) => !left.Equals(right);

        public static explicit operator string(PfsGroup value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PfsGroup other && Equals(other);
        public bool Equals(PfsGroup other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
