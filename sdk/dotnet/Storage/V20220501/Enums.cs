// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Storage.V20220501
{
    /// <summary>
    /// Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs storage account type.
    /// </summary>
    [EnumType]
    public readonly struct AccessTier : IEquatable<AccessTier>
    {
        private readonly string _value;

        private AccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessTier Hot { get; } = new AccessTier("Hot");
        public static AccessTier Cool { get; } = new AccessTier("Cool");
        public static AccessTier Premium { get; } = new AccessTier("Premium");

        public static bool operator ==(AccessTier left, AccessTier right) => left.Equals(right);
        public static bool operator !=(AccessTier left, AccessTier right) => !left.Equals(right);

        public static explicit operator string(AccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessTier other && Equals(other);
        public bool Equals(AccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted.
    /// </summary>
    [EnumType]
    public readonly struct AccountImmutabilityPolicyState : IEquatable<AccountImmutabilityPolicyState>
    {
        private readonly string _value;

        private AccountImmutabilityPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountImmutabilityPolicyState Unlocked { get; } = new AccountImmutabilityPolicyState("Unlocked");
        public static AccountImmutabilityPolicyState Locked { get; } = new AccountImmutabilityPolicyState("Locked");
        public static AccountImmutabilityPolicyState Disabled { get; } = new AccountImmutabilityPolicyState("Disabled");

        public static bool operator ==(AccountImmutabilityPolicyState left, AccountImmutabilityPolicyState right) => left.Equals(right);
        public static bool operator !=(AccountImmutabilityPolicyState left, AccountImmutabilityPolicyState right) => !left.Equals(right);

        public static explicit operator string(AccountImmutabilityPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountImmutabilityPolicyState other && Equals(other);
        public bool Equals(AccountImmutabilityPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the Active Directory account type for Azure Storage.
    /// </summary>
    [EnumType]
    public readonly struct AccountType : IEquatable<AccountType>
    {
        private readonly string _value;

        private AccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountType User { get; } = new AccountType("User");
        public static AccountType Computer { get; } = new AccountType("Computer");

        public static bool operator ==(AccountType left, AccountType right) => left.Equals(right);
        public static bool operator !=(AccountType left, AccountType right) => !left.Equals(right);

        public static explicit operator string(AccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountType other && Equals(other);
        public bool Equals(AccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action of virtual network rule.
    /// </summary>
    [EnumType]
    public readonly struct Action : IEquatable<Action>
    {
        private readonly string _value;

        private Action(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Action Allow { get; } = new Action("Allow");

        public static bool operator ==(Action left, Action right) => left.Equals(right);
        public static bool operator !=(Action left, Action right) => !left.Equals(right);

        public static explicit operator string(Action value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Action other && Equals(other);
        public bool Equals(Action other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.
    /// </summary>
    [EnumType]
    public readonly struct AllowedCopyScope : IEquatable<AllowedCopyScope>
    {
        private readonly string _value;

        private AllowedCopyScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllowedCopyScope PrivateLink { get; } = new AllowedCopyScope("PrivateLink");
        public static AllowedCopyScope AAD { get; } = new AllowedCopyScope("AAD");

        public static bool operator ==(AllowedCopyScope left, AllowedCopyScope right) => left.Equals(right);
        public static bool operator !=(AllowedCopyScope left, AllowedCopyScope right) => !left.Equals(right);

        public static explicit operator string(AllowedCopyScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllowedCopyScope other && Equals(other);
        public bool Equals(AllowedCopyScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct AllowedMethods : IEquatable<AllowedMethods>
    {
        private readonly string _value;

        private AllowedMethods(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllowedMethods DELETE { get; } = new AllowedMethods("DELETE");
        public static AllowedMethods GET { get; } = new AllowedMethods("GET");
        public static AllowedMethods HEAD { get; } = new AllowedMethods("HEAD");
        public static AllowedMethods MERGE { get; } = new AllowedMethods("MERGE");
        public static AllowedMethods POST { get; } = new AllowedMethods("POST");
        public static AllowedMethods OPTIONS { get; } = new AllowedMethods("OPTIONS");
        public static AllowedMethods PUT { get; } = new AllowedMethods("PUT");
        public static AllowedMethods PATCH { get; } = new AllowedMethods("PATCH");

        public static bool operator ==(AllowedMethods left, AllowedMethods right) => left.Equals(right);
        public static bool operator !=(AllowedMethods left, AllowedMethods right) => !left.Equals(right);

        public static explicit operator string(AllowedMethods value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllowedMethods other && Equals(other);
        public bool Equals(AllowedMethods other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
    /// </summary>
    [EnumType]
    public readonly struct Bypass : IEquatable<Bypass>
    {
        private readonly string _value;

        private Bypass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Bypass None { get; } = new Bypass("None");
        public static Bypass Logging { get; } = new Bypass("Logging");
        public static Bypass Metrics { get; } = new Bypass("Metrics");
        public static Bypass AzureServices { get; } = new Bypass("AzureServices");

        public static bool operator ==(Bypass left, Bypass right) => left.Equals(right);
        public static bool operator !=(Bypass left, Bypass right) => !left.Equals(right);

        public static explicit operator string(Bypass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Bypass other && Equals(other);
        public bool Equals(Bypass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the default action of allow or deny when no other rules match.
    /// </summary>
    [EnumType]
    public readonly struct DefaultAction : IEquatable<DefaultAction>
    {
        private readonly string _value;

        private DefaultAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultAction Allow { get; } = new DefaultAction("Allow");
        public static DefaultAction Deny { get; } = new DefaultAction("Deny");

        public static bool operator ==(DefaultAction left, DefaultAction right) => left.Equals(right);
        public static bool operator !=(DefaultAction left, DefaultAction right) => !left.Equals(right);

        public static explicit operator string(DefaultAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultAction other && Equals(other);
        public bool Equals(DefaultAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default share permission for users using Kerberos authentication if RBAC role is not assigned.
    /// </summary>
    [EnumType]
    public readonly struct DefaultSharePermission : IEquatable<DefaultSharePermission>
    {
        private readonly string _value;

        private DefaultSharePermission(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultSharePermission None { get; } = new DefaultSharePermission("None");
        public static DefaultSharePermission StorageFileDataSmbShareReader { get; } = new DefaultSharePermission("StorageFileDataSmbShareReader");
        public static DefaultSharePermission StorageFileDataSmbShareContributor { get; } = new DefaultSharePermission("StorageFileDataSmbShareContributor");
        public static DefaultSharePermission StorageFileDataSmbShareElevatedContributor { get; } = new DefaultSharePermission("StorageFileDataSmbShareElevatedContributor");

        public static bool operator ==(DefaultSharePermission left, DefaultSharePermission right) => left.Equals(right);
        public static bool operator !=(DefaultSharePermission left, DefaultSharePermission right) => !left.Equals(right);

        public static explicit operator string(DefaultSharePermission value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultSharePermission other && Equals(other);
        public bool Equals(DefaultSharePermission other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the directory service used. Note that this enum may be extended in the future.
    /// </summary>
    [EnumType]
    public readonly struct DirectoryServiceOptions : IEquatable<DirectoryServiceOptions>
    {
        private readonly string _value;

        private DirectoryServiceOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DirectoryServiceOptions None { get; } = new DirectoryServiceOptions("None");
        public static DirectoryServiceOptions AADDS { get; } = new DirectoryServiceOptions("AADDS");
        public static DirectoryServiceOptions AD { get; } = new DirectoryServiceOptions("AD");
        public static DirectoryServiceOptions AADKERB { get; } = new DirectoryServiceOptions("AADKERB");

        public static bool operator ==(DirectoryServiceOptions left, DirectoryServiceOptions right) => left.Equals(right);
        public static bool operator !=(DirectoryServiceOptions left, DirectoryServiceOptions right) => !left.Equals(right);

        public static explicit operator string(DirectoryServiceOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DirectoryServiceOptions other && Equals(other);
        public bool Equals(DirectoryServiceOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone identifier.
    /// </summary>
    [EnumType]
    public readonly struct DnsEndpointType : IEquatable<DnsEndpointType>
    {
        private readonly string _value;

        private DnsEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DnsEndpointType Standard { get; } = new DnsEndpointType("Standard");
        public static DnsEndpointType AzureDnsZone { get; } = new DnsEndpointType("AzureDnsZone");

        public static bool operator ==(DnsEndpointType left, DnsEndpointType right) => left.Equals(right);
        public static bool operator !=(DnsEndpointType left, DnsEndpointType right) => !left.Equals(right);

        public static explicit operator string(DnsEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DnsEndpointType other && Equals(other);
        public bool Equals(DnsEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SAS expiration action. Can only be Log.
    /// </summary>
    [EnumType]
    public readonly struct ExpirationAction : IEquatable<ExpirationAction>
    {
        private readonly string _value;

        private ExpirationAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpirationAction Log { get; } = new ExpirationAction("Log");

        public static bool operator ==(ExpirationAction left, ExpirationAction right) => left.Equals(right);
        public static bool operator !=(ExpirationAction left, ExpirationAction right) => !left.Equals(right);

        public static explicit operator string(ExpirationAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpirationAction other && Equals(other);
        public bool Equals(ExpirationAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType None { get; } = new IdentityType("None");
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
    /// </summary>
    [EnumType]
    public readonly struct KeySource : IEquatable<KeySource>
    {
        private readonly string _value;

        private KeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeySource Microsoft_Storage { get; } = new KeySource("Microsoft.Storage");
        public static KeySource Microsoft_Keyvault { get; } = new KeySource("Microsoft.Keyvault");

        public static bool operator ==(KeySource left, KeySource right) => left.Equals(right);
        public static bool operator !=(KeySource left, KeySource right) => !left.Equals(right);

        public static explicit operator string(KeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeySource other && Equals(other);
        public bool Equals(KeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
    /// </summary>
    [EnumType]
    public readonly struct KeyType : IEquatable<KeyType>
    {
        private readonly string _value;

        private KeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyType Service { get; } = new KeyType("Service");
        public static KeyType Account { get; } = new KeyType("Account");

        public static bool operator ==(KeyType left, KeyType right) => left.Equals(right);
        public static bool operator !=(KeyType left, KeyType right) => !left.Equals(right);

        public static explicit operator string(KeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyType other && Equals(other);
        public bool Equals(KeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Indicates the type of storage account.
    /// </summary>
    [EnumType]
    public readonly struct Kind : IEquatable<Kind>
    {
        private readonly string _value;

        private Kind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Kind Storage { get; } = new Kind("Storage");
        public static Kind StorageV2 { get; } = new Kind("StorageV2");
        public static Kind BlobStorage { get; } = new Kind("BlobStorage");
        public static Kind FileStorage { get; } = new Kind("FileStorage");
        public static Kind BlockBlobStorage { get; } = new Kind("BlockBlobStorage");

        public static bool operator ==(Kind left, Kind right) => left.Equals(right);
        public static bool operator !=(Kind left, Kind right) => !left.Equals(right);

        public static explicit operator string(Kind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Kind other && Equals(other);
        public bool Equals(Kind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
    /// </summary>
    [EnumType]
    public readonly struct LargeFileSharesState : IEquatable<LargeFileSharesState>
    {
        private readonly string _value;

        private LargeFileSharesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LargeFileSharesState Disabled { get; } = new LargeFileSharesState("Disabled");
        public static LargeFileSharesState Enabled { get; } = new LargeFileSharesState("Enabled");

        public static bool operator ==(LargeFileSharesState left, LargeFileSharesState right) => left.Equals(right);
        public static bool operator !=(LargeFileSharesState left, LargeFileSharesState right) => !left.Equals(right);

        public static explicit operator string(LargeFileSharesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LargeFileSharesState other && Equals(other);
        public bool Equals(LargeFileSharesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
    /// </summary>
    [EnumType]
    public readonly struct MinimumTlsVersion : IEquatable<MinimumTlsVersion>
    {
        private readonly string _value;

        private MinimumTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MinimumTlsVersion TLS1_0 { get; } = new MinimumTlsVersion("TLS1_0");
        public static MinimumTlsVersion TLS1_1 { get; } = new MinimumTlsVersion("TLS1_1");
        public static MinimumTlsVersion TLS1_2 { get; } = new MinimumTlsVersion("TLS1_2");

        public static bool operator ==(MinimumTlsVersion left, MinimumTlsVersion right) => left.Equals(right);
        public static bool operator !=(MinimumTlsVersion left, MinimumTlsVersion right) => !left.Equals(right);

        public static explicit operator string(MinimumTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimumTlsVersion other && Equals(other);
        public bool Equals(MinimumTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether data in the container may be accessed publicly and the level of access.
    /// </summary>
    [EnumType]
    public readonly struct PublicAccess : IEquatable<PublicAccess>
    {
        private readonly string _value;

        private PublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicAccess Container { get; } = new PublicAccess("Container");
        public static PublicAccess Blob { get; } = new PublicAccess("Blob");
        public static PublicAccess None { get; } = new PublicAccess("None");

        public static bool operator ==(PublicAccess left, PublicAccess right) => left.Equals(right);
        public static bool operator !=(PublicAccess left, PublicAccess right) => !left.Equals(right);

        public static explicit operator string(PublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicAccess other && Equals(other);
        public bool Equals(PublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allow or disallow public network access to Storage Account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Routing Choice defines the kind of network routing opted by the user.
    /// </summary>
    [EnumType]
    public readonly struct RoutingChoice : IEquatable<RoutingChoice>
    {
        private readonly string _value;

        private RoutingChoice(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutingChoice MicrosoftRouting { get; } = new RoutingChoice("MicrosoftRouting");
        public static RoutingChoice InternetRouting { get; } = new RoutingChoice("InternetRouting");

        public static bool operator ==(RoutingChoice left, RoutingChoice right) => left.Equals(right);
        public static bool operator !=(RoutingChoice left, RoutingChoice right) => !left.Equals(right);

        public static explicit operator string(RoutingChoice value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutingChoice other && Equals(other);
        public bool Equals(RoutingChoice other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuName Standard_LRS { get; } = new SkuName("Standard_LRS");
        public static SkuName Standard_GRS { get; } = new SkuName("Standard_GRS");
        public static SkuName Standard_RAGRS { get; } = new SkuName("Standard_RAGRS");
        public static SkuName Standard_ZRS { get; } = new SkuName("Standard_ZRS");
        public static SkuName Premium_LRS { get; } = new SkuName("Premium_LRS");
        public static SkuName Premium_ZRS { get; } = new SkuName("Premium_ZRS");
        public static SkuName Standard_GZRS { get; } = new SkuName("Standard_GZRS");
        public static SkuName Standard_RAGZRS { get; } = new SkuName("Standard_RAGZRS");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Gets the state of virtual network rule.
    /// </summary>
    [EnumType]
    public readonly struct State : IEquatable<State>
    {
        private readonly string _value;

        private State(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static State Provisioning { get; } = new State("Provisioning");
        public static State Deprovisioning { get; } = new State("Deprovisioning");
        public static State Succeeded { get; } = new State("Succeeded");
        public static State Failed { get; } = new State("Failed");
        public static State NetworkSourceDeleted { get; } = new State("NetworkSourceDeleted");

        public static bool operator ==(State left, State right) => left.Equals(right);
        public static bool operator !=(State left, State right) => !left.Equals(right);

        public static explicit operator string(State value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is State other && Equals(other);
        public bool Equals(State other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
