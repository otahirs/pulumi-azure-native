// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Sql.V20220501Preview
{
    /// <summary>
    /// Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct AdministratorType : IEquatable<AdministratorType>
    {
        private readonly string _value;

        private AdministratorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdministratorType ActiveDirectory { get; } = new AdministratorType("ActiveDirectory");

        public static bool operator ==(AdministratorType left, AdministratorType right) => left.Equals(right);
        public static bool operator !=(AdministratorType left, AdministratorType right) => !left.Equals(right);

        public static explicit operator string(AdministratorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdministratorType other && Equals(other);
        public bool Equals(AdministratorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of enclave requested on the database i.e. Default or VBS enclaves.
    /// </summary>
    [EnumType]
    public readonly struct AlwaysEncryptedEnclaveType : IEquatable<AlwaysEncryptedEnclaveType>
    {
        private readonly string _value;

        private AlwaysEncryptedEnclaveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AlwaysEncryptedEnclaveType Default { get; } = new AlwaysEncryptedEnclaveType("Default");
        public static AlwaysEncryptedEnclaveType VBS { get; } = new AlwaysEncryptedEnclaveType("VBS");

        public static bool operator ==(AlwaysEncryptedEnclaveType left, AlwaysEncryptedEnclaveType right) => left.Equals(right);
        public static bool operator !=(AlwaysEncryptedEnclaveType left, AlwaysEncryptedEnclaveType right) => !left.Equals(right);

        public static explicit operator string(AlwaysEncryptedEnclaveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlwaysEncryptedEnclaveType other && Equals(other);
        public bool Equals(AlwaysEncryptedEnclaveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage account type to be used to store backups for this database.
    /// </summary>
    [EnumType]
    public readonly struct BackupStorageRedundancy : IEquatable<BackupStorageRedundancy>
    {
        private readonly string _value;

        private BackupStorageRedundancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackupStorageRedundancy Geo { get; } = new BackupStorageRedundancy("Geo");
        public static BackupStorageRedundancy Local { get; } = new BackupStorageRedundancy("Local");
        public static BackupStorageRedundancy Zone { get; } = new BackupStorageRedundancy("Zone");
        public static BackupStorageRedundancy GeoZone { get; } = new BackupStorageRedundancy("GeoZone");

        public static bool operator ==(BackupStorageRedundancy left, BackupStorageRedundancy right) => left.Equals(right);
        public static bool operator !=(BackupStorageRedundancy left, BackupStorageRedundancy right) => !left.Equals(right);

        public static explicit operator string(BackupStorageRedundancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupStorageRedundancy other && Equals(other);
        public bool Equals(BackupStorageRedundancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the state of the audit. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
    /// </summary>
    [EnumType]
    public readonly struct BlobAuditingPolicyState : IEquatable<BlobAuditingPolicyState>
    {
        private readonly string _value;

        private BlobAuditingPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BlobAuditingPolicyState Enabled { get; } = new BlobAuditingPolicyState("Enabled");
        public static BlobAuditingPolicyState Disabled { get; } = new BlobAuditingPolicyState("Disabled");

        public static bool operator ==(BlobAuditingPolicyState left, BlobAuditingPolicyState right) => left.Equals(right);
        public static bool operator !=(BlobAuditingPolicyState left, BlobAuditingPolicyState right) => !left.Equals(right);

        public static explicit operator string(BlobAuditingPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BlobAuditingPolicyState other && Equals(other);
        public bool Equals(BlobAuditingPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Collation of the metadata catalog.
    /// </summary>
    [EnumType]
    public readonly struct CatalogCollationType : IEquatable<CatalogCollationType>
    {
        private readonly string _value;

        private CatalogCollationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CatalogCollationType DATABASE_DEFAULT { get; } = new CatalogCollationType("DATABASE_DEFAULT");
        public static CatalogCollationType SQL_Latin1_General_CP1_CI_AS { get; } = new CatalogCollationType("SQL_Latin1_General_CP1_CI_AS");

        public static bool operator ==(CatalogCollationType left, CatalogCollationType right) => left.Equals(right);
        public static bool operator !=(CatalogCollationType left, CatalogCollationType right) => !left.Equals(right);

        public static explicit operator string(CatalogCollationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CatalogCollationType other && Equals(other);
        public bool Equals(CatalogCollationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of database creation.
    /// 
    /// Default: regular database creation.
    /// 
    /// Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.
    /// 
    /// Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.
    /// 
    /// PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
    /// 
    /// Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.
    /// 
    /// Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.
    /// 
    /// RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
    /// 
    /// Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
    /// </summary>
    [EnumType]
    public readonly struct CreateMode : IEquatable<CreateMode>
    {
        private readonly string _value;

        private CreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreateMode Default { get; } = new CreateMode("Default");
        public static CreateMode Copy { get; } = new CreateMode("Copy");
        public static CreateMode Secondary { get; } = new CreateMode("Secondary");
        public static CreateMode PointInTimeRestore { get; } = new CreateMode("PointInTimeRestore");
        public static CreateMode Restore { get; } = new CreateMode("Restore");
        public static CreateMode Recovery { get; } = new CreateMode("Recovery");
        public static CreateMode RestoreExternalBackup { get; } = new CreateMode("RestoreExternalBackup");
        public static CreateMode RestoreExternalBackupSecondary { get; } = new CreateMode("RestoreExternalBackupSecondary");
        public static CreateMode RestoreLongTermRetentionBackup { get; } = new CreateMode("RestoreLongTermRetentionBackup");
        public static CreateMode OnlineSecondary { get; } = new CreateMode("OnlineSecondary");

        public static bool operator ==(CreateMode left, CreateMode right) => left.Equals(right);
        public static bool operator !=(CreateMode left, CreateMode right) => !left.Equals(right);

        public static explicit operator string(CreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreateMode other && Equals(other);
        public bool Equals(CreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type
    /// </summary>
    [EnumType]
    public readonly struct DatabaseIdentityType : IEquatable<DatabaseIdentityType>
    {
        private readonly string _value;

        private DatabaseIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseIdentityType None { get; } = new DatabaseIdentityType("None");
        public static DatabaseIdentityType UserAssigned { get; } = new DatabaseIdentityType("UserAssigned");

        public static bool operator ==(DatabaseIdentityType left, DatabaseIdentityType right) => left.Equals(right);
        public static bool operator !=(DatabaseIdentityType left, DatabaseIdentityType right) => !left.Equals(right);

        public static explicit operator string(DatabaseIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseIdentityType other && Equals(other);
        public bool Equals(DatabaseIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to apply for this database. `LicenseIncluded` if you need a license, or `BasePrice` if you have a license and are eligible for the Azure Hybrid Benefit.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseLicenseType : IEquatable<DatabaseLicenseType>
    {
        private readonly string _value;

        private DatabaseLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseLicenseType LicenseIncluded { get; } = new DatabaseLicenseType("LicenseIncluded");
        public static DatabaseLicenseType BasePrice { get; } = new DatabaseLicenseType("BasePrice");

        public static bool operator ==(DatabaseLicenseType left, DatabaseLicenseType right) => left.Equals(right);
        public static bool operator !=(DatabaseLicenseType left, DatabaseLicenseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseLicenseType other && Equals(other);
        public bool Equals(DatabaseLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of read-only routing. If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale database within an elastic pool.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseReadScale : IEquatable<DatabaseReadScale>
    {
        private readonly string _value;

        private DatabaseReadScale(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseReadScale Enabled { get; } = new DatabaseReadScale("Enabled");
        public static DatabaseReadScale Disabled { get; } = new DatabaseReadScale("Disabled");

        public static bool operator ==(DatabaseReadScale left, DatabaseReadScale right) => left.Equals(right);
        public static bool operator !=(DatabaseReadScale left, DatabaseReadScale right) => !left.Equals(right);

        public static explicit operator string(DatabaseReadScale value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseReadScale other && Equals(other);
        public bool Equals(DatabaseReadScale other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType None { get; } = new IdentityType("None");
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Principal Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct PrincipalType : IEquatable<PrincipalType>
    {
        private readonly string _value;

        private PrincipalType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrincipalType User { get; } = new PrincipalType("User");
        public static PrincipalType Group { get; } = new PrincipalType("Group");
        public static PrincipalType Application { get; } = new PrincipalType("Application");

        public static bool operator ==(PrincipalType left, PrincipalType right) => left.Equals(right);
        public static bool operator !=(PrincipalType left, PrincipalType right) => !left.Equals(right);

        public static explicit operator string(PrincipalType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrincipalType other && Equals(other);
        public bool Equals(PrincipalType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the sample schema to apply when creating this database.
    /// </summary>
    [EnumType]
    public readonly struct SampleName : IEquatable<SampleName>
    {
        private readonly string _value;

        private SampleName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SampleName AdventureWorksLT { get; } = new SampleName("AdventureWorksLT");
        public static SampleName WideWorldImportersStd { get; } = new SampleName("WideWorldImportersStd");
        public static SampleName WideWorldImportersFull { get; } = new SampleName("WideWorldImportersFull");

        public static bool operator ==(SampleName left, SampleName right) => left.Equals(right);
        public static bool operator !=(SampleName left, SampleName right) => !left.Equals(right);

        public static explicit operator string(SampleName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SampleName other && Equals(other);
        public bool Equals(SampleName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The secondary type of the database if it is a secondary.  Valid values are Geo, Named and Standby.
    /// </summary>
    [EnumType]
    public readonly struct SecondaryType : IEquatable<SecondaryType>
    {
        private readonly string _value;

        private SecondaryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecondaryType Geo { get; } = new SecondaryType("Geo");
        public static SecondaryType Named { get; } = new SecondaryType("Named");
        public static SecondaryType Standby { get; } = new SecondaryType("Standby");

        public static bool operator ==(SecondaryType left, SecondaryType right) => left.Equals(right);
        public static bool operator !=(SecondaryType left, SecondaryType right) => !left.Equals(right);

        public static explicit operator string(SecondaryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecondaryType other && Equals(other);
        public bool Equals(SecondaryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not to restrict outbound network access for this server.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct ServerNetworkAccessFlag : IEquatable<ServerNetworkAccessFlag>
    {
        private readonly string _value;

        private ServerNetworkAccessFlag(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerNetworkAccessFlag Enabled { get; } = new ServerNetworkAccessFlag("Enabled");
        public static ServerNetworkAccessFlag Disabled { get; } = new ServerNetworkAccessFlag("Disabled");

        public static bool operator ==(ServerNetworkAccessFlag left, ServerNetworkAccessFlag right) => left.Equals(right);
        public static bool operator !=(ServerNetworkAccessFlag left, ServerNetworkAccessFlag right) => !left.Equals(right);

        public static explicit operator string(ServerNetworkAccessFlag value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerNetworkAccessFlag other && Equals(other);
        public bool Equals(ServerNetworkAccessFlag other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
