# coding=utf-8
# *** WARNING: this file was generated by pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActiveDirectoryPropertiesResponse',
    'AzureFilesIdentityBasedAuthenticationResponse',
    'BlobRestoreParametersResponse',
    'BlobRestoreRangeResponse',
    'BlobRestoreStatusResponse',
    'CustomDomainResponse',
    'EncryptionIdentityResponse',
    'EncryptionResponse',
    'EncryptionServiceResponse',
    'EncryptionServicesResponse',
    'EndpointsResponse',
    'ExtendedLocationResponse',
    'GeoReplicationStatsResponse',
    'IPRuleResponse',
    'IdentityResponse',
    'KeyVaultPropertiesResponse',
    'NetworkRuleSetResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'ResourceAccessRuleResponse',
    'RoutingPreferenceResponse',
    'SkuResponse',
    'StorageAccountInternetEndpointsResponse',
    'StorageAccountMicrosoftEndpointsResponse',
    'UserAssignedIdentityResponse',
    'VirtualNetworkRuleResponse',
]

@pulumi.output_type
class ActiveDirectoryPropertiesResponse(dict):
    """
    Settings properties for Active Directory (AD).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureStorageSid":
            suggest = "azure_storage_sid"
        elif key == "domainGuid":
            suggest = "domain_guid"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainSid":
            suggest = "domain_sid"
        elif key == "forestName":
            suggest = "forest_name"
        elif key == "netBiosDomainName":
            suggest = "net_bios_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_storage_sid: str,
                 domain_guid: str,
                 domain_name: str,
                 domain_sid: str,
                 forest_name: str,
                 net_bios_domain_name: str):
        """
        Settings properties for Active Directory (AD).
        :param str azure_storage_sid: Specifies the security identifier (SID) for Azure Storage.
        :param str domain_guid: Specifies the domain GUID.
        :param str domain_name: Specifies the primary domain that the AD DNS server is authoritative for.
        :param str domain_sid: Specifies the security identifier (SID).
        :param str forest_name: Specifies the Active Directory forest to get.
        :param str net_bios_domain_name: Specifies the NetBIOS domain name.
        """
        pulumi.set(__self__, "azure_storage_sid", azure_storage_sid)
        pulumi.set(__self__, "domain_guid", domain_guid)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "domain_sid", domain_sid)
        pulumi.set(__self__, "forest_name", forest_name)
        pulumi.set(__self__, "net_bios_domain_name", net_bios_domain_name)

    @property
    @pulumi.getter(name="azureStorageSid")
    def azure_storage_sid(self) -> str:
        """
        Specifies the security identifier (SID) for Azure Storage.
        """
        return pulumi.get(self, "azure_storage_sid")

    @property
    @pulumi.getter(name="domainGuid")
    def domain_guid(self) -> str:
        """
        Specifies the domain GUID.
        """
        return pulumi.get(self, "domain_guid")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        Specifies the primary domain that the AD DNS server is authoritative for.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainSid")
    def domain_sid(self) -> str:
        """
        Specifies the security identifier (SID).
        """
        return pulumi.get(self, "domain_sid")

    @property
    @pulumi.getter(name="forestName")
    def forest_name(self) -> str:
        """
        Specifies the Active Directory forest to get.
        """
        return pulumi.get(self, "forest_name")

    @property
    @pulumi.getter(name="netBiosDomainName")
    def net_bios_domain_name(self) -> str:
        """
        Specifies the NetBIOS domain name.
        """
        return pulumi.get(self, "net_bios_domain_name")


@pulumi.output_type
class AzureFilesIdentityBasedAuthenticationResponse(dict):
    """
    Settings for Azure Files identity based authentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryServiceOptions":
            suggest = "directory_service_options"
        elif key == "activeDirectoryProperties":
            suggest = "active_directory_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFilesIdentityBasedAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFilesIdentityBasedAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFilesIdentityBasedAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory_service_options: str,
                 active_directory_properties: Optional['outputs.ActiveDirectoryPropertiesResponse'] = None):
        """
        Settings for Azure Files identity based authentication.
        :param str directory_service_options: Indicates the directory service used.
        :param 'ActiveDirectoryPropertiesResponse' active_directory_properties: Required if choose AD.
        """
        pulumi.set(__self__, "directory_service_options", directory_service_options)
        if active_directory_properties is not None:
            pulumi.set(__self__, "active_directory_properties", active_directory_properties)

    @property
    @pulumi.getter(name="directoryServiceOptions")
    def directory_service_options(self) -> str:
        """
        Indicates the directory service used.
        """
        return pulumi.get(self, "directory_service_options")

    @property
    @pulumi.getter(name="activeDirectoryProperties")
    def active_directory_properties(self) -> Optional['outputs.ActiveDirectoryPropertiesResponse']:
        """
        Required if choose AD.
        """
        return pulumi.get(self, "active_directory_properties")


@pulumi.output_type
class BlobRestoreParametersResponse(dict):
    """
    Blob restore parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobRanges":
            suggest = "blob_ranges"
        elif key == "timeToRestore":
            suggest = "time_to_restore"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobRestoreParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobRestoreParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobRestoreParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_ranges: Sequence['outputs.BlobRestoreRangeResponse'],
                 time_to_restore: str):
        """
        Blob restore parameters
        :param Sequence['BlobRestoreRangeResponse'] blob_ranges: Blob ranges to restore.
        :param str time_to_restore: Restore blob to the specified time.
        """
        pulumi.set(__self__, "blob_ranges", blob_ranges)
        pulumi.set(__self__, "time_to_restore", time_to_restore)

    @property
    @pulumi.getter(name="blobRanges")
    def blob_ranges(self) -> Sequence['outputs.BlobRestoreRangeResponse']:
        """
        Blob ranges to restore.
        """
        return pulumi.get(self, "blob_ranges")

    @property
    @pulumi.getter(name="timeToRestore")
    def time_to_restore(self) -> str:
        """
        Restore blob to the specified time.
        """
        return pulumi.get(self, "time_to_restore")


@pulumi.output_type
class BlobRestoreRangeResponse(dict):
    """
    Blob range
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endRange":
            suggest = "end_range"
        elif key == "startRange":
            suggest = "start_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobRestoreRangeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobRestoreRangeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobRestoreRangeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_range: str,
                 start_range: str):
        """
        Blob range
        :param str end_range: Blob end range. This is exclusive. Empty means account end.
        :param str start_range: Blob start range. This is inclusive. Empty means account start.
        """
        pulumi.set(__self__, "end_range", end_range)
        pulumi.set(__self__, "start_range", start_range)

    @property
    @pulumi.getter(name="endRange")
    def end_range(self) -> str:
        """
        Blob end range. This is exclusive. Empty means account end.
        """
        return pulumi.get(self, "end_range")

    @property
    @pulumi.getter(name="startRange")
    def start_range(self) -> str:
        """
        Blob start range. This is inclusive. Empty means account start.
        """
        return pulumi.get(self, "start_range")


@pulumi.output_type
class BlobRestoreStatusResponse(dict):
    """
    Blob restore status.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureReason":
            suggest = "failure_reason"
        elif key == "restoreId":
            suggest = "restore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobRestoreStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobRestoreStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobRestoreStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_reason: str,
                 parameters: 'outputs.BlobRestoreParametersResponse',
                 restore_id: str,
                 status: str):
        """
        Blob restore status.
        :param str failure_reason: Failure reason when blob restore is failed.
        :param 'BlobRestoreParametersResponse' parameters: Blob restore request parameters.
        :param str restore_id: Id for tracking blob restore request.
        :param str status: The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
        """
        pulumi.set(__self__, "failure_reason", failure_reason)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "restore_id", restore_id)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> str:
        """
        Failure reason when blob restore is failed.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.BlobRestoreParametersResponse':
        """
        Blob restore request parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="restoreId")
    def restore_id(self) -> str:
        """
        Id for tracking blob restore request.
        """
        return pulumi.get(self, "restore_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CustomDomainResponse(dict):
    """
    The custom domain assigned to this storage account. This can be set via Update.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useSubDomainName":
            suggest = "use_sub_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 use_sub_domain_name: Optional[bool] = None):
        """
        The custom domain assigned to this storage account. This can be set via Update.
        :param str name: Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
        :param bool use_sub_domain_name: Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
        """
        pulumi.set(__self__, "name", name)
        if use_sub_domain_name is not None:
            pulumi.set(__self__, "use_sub_domain_name", use_sub_domain_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="useSubDomainName")
    def use_sub_domain_name(self) -> Optional[bool]:
        """
        Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
        """
        return pulumi.get(self, "use_sub_domain_name")


@pulumi.output_type
class EncryptionIdentityResponse(dict):
    """
    Encryption identity for the storage account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionUserAssignedIdentity":
            suggest = "encryption_user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_user_assigned_identity: Optional[str] = None):
        """
        Encryption identity for the storage account.
        :param str encryption_user_assigned_identity: Resource identifier of the UserAssigned identity to be associated with server-side encryption on the storage account.
        """
        if encryption_user_assigned_identity is not None:
            pulumi.set(__self__, "encryption_user_assigned_identity", encryption_user_assigned_identity)

    @property
    @pulumi.getter(name="encryptionUserAssignedIdentity")
    def encryption_user_assigned_identity(self) -> Optional[str]:
        """
        Resource identifier of the UserAssigned identity to be associated with server-side encryption on the storage account.
        """
        return pulumi.get(self, "encryption_user_assigned_identity")


@pulumi.output_type
class EncryptionResponse(dict):
    """
    The encryption settings on the storage account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "encryptionIdentity":
            suggest = "encryption_identity"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"
        elif key == "requireInfrastructureEncryption":
            suggest = "require_infrastructure_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_source: str,
                 encryption_identity: Optional['outputs.EncryptionIdentityResponse'] = None,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None,
                 require_infrastructure_encryption: Optional[bool] = None,
                 services: Optional['outputs.EncryptionServicesResponse'] = None):
        """
        The encryption settings on the storage account.
        :param str key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
        :param 'EncryptionIdentityResponse' encryption_identity: The identity to be used with service-side encryption at rest.
        :param 'KeyVaultPropertiesResponse' key_vault_properties: Properties provided by key vault.
        :param bool require_infrastructure_encryption: A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest.
        :param 'EncryptionServicesResponse' services: List of services which support encryption.
        """
        if key_source is None:
            key_source = 'Microsoft.Storage'
        pulumi.set(__self__, "key_source", key_source)
        if encryption_identity is not None:
            pulumi.set(__self__, "encryption_identity", encryption_identity)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if require_infrastructure_encryption is not None:
            pulumi.set(__self__, "require_infrastructure_encryption", require_infrastructure_encryption)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> str:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="encryptionIdentity")
    def encryption_identity(self) -> Optional['outputs.EncryptionIdentityResponse']:
        """
        The identity to be used with service-side encryption at rest.
        """
        return pulumi.get(self, "encryption_identity")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        Properties provided by key vault.
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter(name="requireInfrastructureEncryption")
    def require_infrastructure_encryption(self) -> Optional[bool]:
        """
        A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest.
        """
        return pulumi.get(self, "require_infrastructure_encryption")

    @property
    @pulumi.getter
    def services(self) -> Optional['outputs.EncryptionServicesResponse']:
        """
        List of services which support encryption.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class EncryptionServiceResponse(dict):
    """
    A service that allows server-side encryption to be used.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastEnabledTime":
            suggest = "last_enabled_time"
        elif key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_enabled_time: str,
                 enabled: Optional[bool] = None,
                 key_type: Optional[str] = None):
        """
        A service that allows server-side encryption to be used.
        :param str last_enabled_time: Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
        :param bool enabled: A boolean indicating whether or not the service encrypts the data as it is stored.
        :param str key_type: Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
        """
        pulumi.set(__self__, "last_enabled_time", last_enabled_time)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="lastEnabledTime")
    def last_enabled_time(self) -> str:
        """
        Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
        """
        return pulumi.get(self, "last_enabled_time")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A boolean indicating whether or not the service encrypts the data as it is stored.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
        """
        return pulumi.get(self, "key_type")


@pulumi.output_type
class EncryptionServicesResponse(dict):
    """
    A list of services that support encryption.
    """
    def __init__(__self__, *,
                 blob: Optional['outputs.EncryptionServiceResponse'] = None,
                 file: Optional['outputs.EncryptionServiceResponse'] = None,
                 queue: Optional['outputs.EncryptionServiceResponse'] = None,
                 table: Optional['outputs.EncryptionServiceResponse'] = None):
        """
        A list of services that support encryption.
        :param 'EncryptionServiceResponse' blob: The encryption function of the blob storage service.
        :param 'EncryptionServiceResponse' file: The encryption function of the file storage service.
        :param 'EncryptionServiceResponse' queue: The encryption function of the queue storage service.
        :param 'EncryptionServiceResponse' table: The encryption function of the table storage service.
        """
        if blob is not None:
            pulumi.set(__self__, "blob", blob)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def blob(self) -> Optional['outputs.EncryptionServiceResponse']:
        """
        The encryption function of the blob storage service.
        """
        return pulumi.get(self, "blob")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.EncryptionServiceResponse']:
        """
        The encryption function of the file storage service.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def queue(self) -> Optional['outputs.EncryptionServiceResponse']:
        """
        The encryption function of the queue storage service.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter
    def table(self) -> Optional['outputs.EncryptionServiceResponse']:
        """
        The encryption function of the table storage service.
        """
        return pulumi.get(self, "table")


@pulumi.output_type
class EndpointsResponse(dict):
    """
    The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetEndpoints":
            suggest = "internet_endpoints"
        elif key == "microsoftEndpoints":
            suggest = "microsoft_endpoints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob: str,
                 dfs: str,
                 file: str,
                 queue: str,
                 table: str,
                 web: str,
                 internet_endpoints: Optional['outputs.StorageAccountInternetEndpointsResponse'] = None,
                 microsoft_endpoints: Optional['outputs.StorageAccountMicrosoftEndpointsResponse'] = None):
        """
        The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
        :param str blob: Gets the blob endpoint.
        :param str dfs: Gets the dfs endpoint.
        :param str file: Gets the file endpoint.
        :param str queue: Gets the queue endpoint.
        :param str table: Gets the table endpoint.
        :param str web: Gets the web endpoint.
        :param 'StorageAccountInternetEndpointsResponse' internet_endpoints: Gets the internet routing storage endpoints
        :param 'StorageAccountMicrosoftEndpointsResponse' microsoft_endpoints: Gets the microsoft routing storage endpoints.
        """
        pulumi.set(__self__, "blob", blob)
        pulumi.set(__self__, "dfs", dfs)
        pulumi.set(__self__, "file", file)
        pulumi.set(__self__, "queue", queue)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "web", web)
        if internet_endpoints is not None:
            pulumi.set(__self__, "internet_endpoints", internet_endpoints)
        if microsoft_endpoints is not None:
            pulumi.set(__self__, "microsoft_endpoints", microsoft_endpoints)

    @property
    @pulumi.getter
    def blob(self) -> str:
        """
        Gets the blob endpoint.
        """
        return pulumi.get(self, "blob")

    @property
    @pulumi.getter
    def dfs(self) -> str:
        """
        Gets the dfs endpoint.
        """
        return pulumi.get(self, "dfs")

    @property
    @pulumi.getter
    def file(self) -> str:
        """
        Gets the file endpoint.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        Gets the queue endpoint.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        Gets the table endpoint.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def web(self) -> str:
        """
        Gets the web endpoint.
        """
        return pulumi.get(self, "web")

    @property
    @pulumi.getter(name="internetEndpoints")
    def internet_endpoints(self) -> Optional['outputs.StorageAccountInternetEndpointsResponse']:
        """
        Gets the internet routing storage endpoints
        """
        return pulumi.get(self, "internet_endpoints")

    @property
    @pulumi.getter(name="microsoftEndpoints")
    def microsoft_endpoints(self) -> Optional['outputs.StorageAccountMicrosoftEndpointsResponse']:
        """
        Gets the microsoft routing storage endpoints.
        """
        return pulumi.get(self, "microsoft_endpoints")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    The complex type of the extended location.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The complex type of the extended location.
        :param str name: The name of the extended location.
        :param str type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GeoReplicationStatsResponse(dict):
    """
    Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canFailover":
            suggest = "can_failover"
        elif key == "lastSyncTime":
            suggest = "last_sync_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoReplicationStatsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoReplicationStatsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoReplicationStatsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_failover: bool,
                 last_sync_time: str,
                 status: str):
        """
        Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
        :param bool can_failover: A boolean flag which indicates whether or not account failover is supported for the account.
        :param str last_sync_time: All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
        :param str status: The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
        """
        pulumi.set(__self__, "can_failover", can_failover)
        pulumi.set(__self__, "last_sync_time", last_sync_time)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="canFailover")
    def can_failover(self) -> bool:
        """
        A boolean flag which indicates whether or not account failover is supported for the account.
        """
        return pulumi.get(self, "can_failover")

    @property
    @pulumi.getter(name="lastSyncTime")
    def last_sync_time(self) -> str:
        """
        All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
        """
        return pulumi.get(self, "last_sync_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class IPRuleResponse(dict):
    """
    IP rule with specific IP or IP range in CIDR format.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iPAddressOrRange":
            suggest = "i_p_address_or_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 i_p_address_or_range: str,
                 action: Optional[str] = None):
        """
        IP rule with specific IP or IP range in CIDR format.
        :param str i_p_address_or_range: Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
        :param str action: The action of IP ACL rule.
        """
        pulumi.set(__self__, "i_p_address_or_range", i_p_address_or_range)
        if action is None:
            action = 'Allow'
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="iPAddressOrRange")
    def i_p_address_or_range(self) -> str:
        """
        Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
        """
        return pulumi.get(self, "i_p_address_or_range")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action of IP ACL rule.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties of key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentVersionedKeyIdentifier":
            suggest = "current_versioned_key_identifier"
        elif key == "lastKeyRotationTimestamp":
            suggest = "last_key_rotation_timestamp"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "keyVersion":
            suggest = "key_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_versioned_key_identifier: str,
                 last_key_rotation_timestamp: str,
                 key_name: Optional[str] = None,
                 key_vault_uri: Optional[str] = None,
                 key_version: Optional[str] = None):
        """
        Properties of key vault.
        :param str current_versioned_key_identifier: The object identifier of the current versioned Key Vault Key in use.
        :param str last_key_rotation_timestamp: Timestamp of last rotation of the Key Vault Key.
        :param str key_name: The name of KeyVault key.
        :param str key_vault_uri: The Uri of KeyVault.
        :param str key_version: The version of KeyVault key.
        """
        pulumi.set(__self__, "current_versioned_key_identifier", current_versioned_key_identifier)
        pulumi.set(__self__, "last_key_rotation_timestamp", last_key_rotation_timestamp)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @property
    @pulumi.getter(name="currentVersionedKeyIdentifier")
    def current_versioned_key_identifier(self) -> str:
        """
        The object identifier of the current versioned Key Vault Key in use.
        """
        return pulumi.get(self, "current_versioned_key_identifier")

    @property
    @pulumi.getter(name="lastKeyRotationTimestamp")
    def last_key_rotation_timestamp(self) -> str:
        """
        Timestamp of last rotation of the Key Vault Key.
        """
        return pulumi.get(self, "last_key_rotation_timestamp")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[str]:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[str]:
        """
        The version of KeyVault key.
        """
        return pulumi.get(self, "key_version")


@pulumi.output_type
class NetworkRuleSetResponse(dict):
    """
    Network rule set
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAction":
            suggest = "default_action"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "resourceAccessRules":
            suggest = "resource_access_rules"
        elif key == "virtualNetworkRules":
            suggest = "virtual_network_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRuleSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRuleSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRuleSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_action: str,
                 bypass: Optional[str] = None,
                 ip_rules: Optional[Sequence['outputs.IPRuleResponse']] = None,
                 resource_access_rules: Optional[Sequence['outputs.ResourceAccessRuleResponse']] = None,
                 virtual_network_rules: Optional[Sequence['outputs.VirtualNetworkRuleResponse']] = None):
        """
        Network rule set
        :param str default_action: Specifies the default action of allow or deny when no other rules match.
        :param str bypass: Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
        :param Sequence['IPRuleResponse'] ip_rules: Sets the IP ACL rules
        :param Sequence['ResourceAccessRuleResponse'] resource_access_rules: Sets the resource access rules
        :param Sequence['VirtualNetworkRuleResponse'] virtual_network_rules: Sets the virtual network rules
        """
        if default_action is None:
            default_action = 'Allow'
        pulumi.set(__self__, "default_action", default_action)
        if bypass is None:
            bypass = 'AzureServices'
        if bypass is not None:
            pulumi.set(__self__, "bypass", bypass)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if resource_access_rules is not None:
            pulumi.set(__self__, "resource_access_rules", resource_access_rules)
        if virtual_network_rules is not None:
            pulumi.set(__self__, "virtual_network_rules", virtual_network_rules)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> str:
        """
        Specifies the default action of allow or deny when no other rules match.
        """
        return pulumi.get(self, "default_action")

    @property
    @pulumi.getter
    def bypass(self) -> Optional[str]:
        """
        Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
        """
        return pulumi.get(self, "bypass")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.IPRuleResponse']]:
        """
        Sets the IP ACL rules
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="resourceAccessRules")
    def resource_access_rules(self) -> Optional[Sequence['outputs.ResourceAccessRuleResponse']]:
        """
        Sets the resource access rules
        """
        return pulumi.get(self, "resource_access_rules")

    @property
    @pulumi.getter(name="virtualNetworkRules")
    def virtual_network_rules(self) -> Optional[Sequence['outputs.VirtualNetworkRuleResponse']]:
        """
        Sets the virtual network rules
        """
        return pulumi.get(self, "virtual_network_rules")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 type: str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None):
        """
        The Private Endpoint Connection resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionRequired":
            suggest = "action_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str action_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if action_required is not None:
            pulumi.set(__self__, "action_required", action_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionRequired")
    def action_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "action_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ResourceAccessRuleResponse(dict):
    """
    Resource Access Rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAccessRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAccessRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAccessRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Resource Access Rule.
        :param str resource_id: Resource Id
        :param str tenant_id: Tenant Id
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Resource Id
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant Id
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class RoutingPreferenceResponse(dict):
    """
    Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user data, the default option is microsoft routing
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publishInternetEndpoints":
            suggest = "publish_internet_endpoints"
        elif key == "publishMicrosoftEndpoints":
            suggest = "publish_microsoft_endpoints"
        elif key == "routingChoice":
            suggest = "routing_choice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingPreferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingPreferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingPreferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publish_internet_endpoints: Optional[bool] = None,
                 publish_microsoft_endpoints: Optional[bool] = None,
                 routing_choice: Optional[str] = None):
        """
        Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user data, the default option is microsoft routing
        :param bool publish_internet_endpoints: A boolean flag which indicates whether internet routing storage endpoints are to be published
        :param bool publish_microsoft_endpoints: A boolean flag which indicates whether microsoft routing storage endpoints are to be published
        :param str routing_choice: Routing Choice defines the kind of network routing opted by the user.
        """
        if publish_internet_endpoints is not None:
            pulumi.set(__self__, "publish_internet_endpoints", publish_internet_endpoints)
        if publish_microsoft_endpoints is not None:
            pulumi.set(__self__, "publish_microsoft_endpoints", publish_microsoft_endpoints)
        if routing_choice is not None:
            pulumi.set(__self__, "routing_choice", routing_choice)

    @property
    @pulumi.getter(name="publishInternetEndpoints")
    def publish_internet_endpoints(self) -> Optional[bool]:
        """
        A boolean flag which indicates whether internet routing storage endpoints are to be published
        """
        return pulumi.get(self, "publish_internet_endpoints")

    @property
    @pulumi.getter(name="publishMicrosoftEndpoints")
    def publish_microsoft_endpoints(self) -> Optional[bool]:
        """
        A boolean flag which indicates whether microsoft routing storage endpoints are to be published
        """
        return pulumi.get(self, "publish_microsoft_endpoints")

    @property
    @pulumi.getter(name="routingChoice")
    def routing_choice(self) -> Optional[str]:
        """
        Routing Choice defines the kind of network routing opted by the user.
        """
        return pulumi.get(self, "routing_choice")


@pulumi.output_type
class SkuResponse(dict):
    """
    The SKU of the storage account.
    """
    def __init__(__self__, *,
                 name: str,
                 tier: str):
        """
        The SKU of the storage account.
        :param str name: The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
        :param str tier: The SKU tier. This is based on the SKU name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The SKU tier. This is based on the SKU name.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StorageAccountInternetEndpointsResponse(dict):
    """
    The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
    """
    def __init__(__self__, *,
                 blob: str,
                 dfs: str,
                 file: str,
                 web: str):
        """
        The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
        :param str blob: Gets the blob endpoint.
        :param str dfs: Gets the dfs endpoint.
        :param str file: Gets the file endpoint.
        :param str web: Gets the web endpoint.
        """
        pulumi.set(__self__, "blob", blob)
        pulumi.set(__self__, "dfs", dfs)
        pulumi.set(__self__, "file", file)
        pulumi.set(__self__, "web", web)

    @property
    @pulumi.getter
    def blob(self) -> str:
        """
        Gets the blob endpoint.
        """
        return pulumi.get(self, "blob")

    @property
    @pulumi.getter
    def dfs(self) -> str:
        """
        Gets the dfs endpoint.
        """
        return pulumi.get(self, "dfs")

    @property
    @pulumi.getter
    def file(self) -> str:
        """
        Gets the file endpoint.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def web(self) -> str:
        """
        Gets the web endpoint.
        """
        return pulumi.get(self, "web")


@pulumi.output_type
class StorageAccountMicrosoftEndpointsResponse(dict):
    """
    The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing endpoint.
    """
    def __init__(__self__, *,
                 blob: str,
                 dfs: str,
                 file: str,
                 queue: str,
                 table: str,
                 web: str):
        """
        The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing endpoint.
        :param str blob: Gets the blob endpoint.
        :param str dfs: Gets the dfs endpoint.
        :param str file: Gets the file endpoint.
        :param str queue: Gets the queue endpoint.
        :param str table: Gets the table endpoint.
        :param str web: Gets the web endpoint.
        """
        pulumi.set(__self__, "blob", blob)
        pulumi.set(__self__, "dfs", dfs)
        pulumi.set(__self__, "file", file)
        pulumi.set(__self__, "queue", queue)
        pulumi.set(__self__, "table", table)
        pulumi.set(__self__, "web", web)

    @property
    @pulumi.getter
    def blob(self) -> str:
        """
        Gets the blob endpoint.
        """
        return pulumi.get(self, "blob")

    @property
    @pulumi.getter
    def dfs(self) -> str:
        """
        Gets the dfs endpoint.
        """
        return pulumi.get(self, "dfs")

    @property
    @pulumi.getter
    def file(self) -> str:
        """
        Gets the file endpoint.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        Gets the queue endpoint.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter
    def table(self) -> str:
        """
        Gets the table endpoint.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def web(self) -> str:
        """
        Gets the web endpoint.
        """
        return pulumi.get(self, "web")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    UserAssignedIdentity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        UserAssignedIdentity for the resource.
        :param str client_id: The client ID of the identity.
        :param str principal_id: The principal ID of the identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualNetworkRuleResponse(dict):
    """
    Virtual Network rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualNetworkResourceId":
            suggest = "virtual_network_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_network_resource_id: str,
                 action: Optional[str] = None,
                 state: Optional[str] = None):
        """
        Virtual Network rule.
        :param str virtual_network_resource_id: Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
        :param str action: The action of virtual network rule.
        :param str state: Gets the state of virtual network rule.
        """
        pulumi.set(__self__, "virtual_network_resource_id", virtual_network_resource_id)
        if action is None:
            action = 'Allow'
        if action is not None:
            pulumi.set(__self__, "action", action)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="virtualNetworkResourceId")
    def virtual_network_resource_id(self) -> str:
        """
        Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
        """
        return pulumi.get(self, "virtual_network_resource_id")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action of virtual network rule.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Gets the state of virtual network rule.
        """
        return pulumi.get(self, "state")


